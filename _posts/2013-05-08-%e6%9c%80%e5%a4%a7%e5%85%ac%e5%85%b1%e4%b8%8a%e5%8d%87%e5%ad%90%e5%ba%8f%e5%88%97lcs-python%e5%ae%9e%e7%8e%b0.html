---
layout: post
title: 最大公共上升子序列(lcs) python实现
categories:
- program
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _oembed_99b9da6ba9cab9267f129a34228d0b48: '{{unknown}}'
  _oembed_790e01935d1e7818f27db1ae9f673a55: '{{unknown}}'
  _sinaweibo_sync: 'true'
  _sinaweibo_sync_id: '3575661535392997'
  _social_notify: '1'
  _social_broadcast_content: 'a:1:{s:7:"twitter";a:1:{i:334092962;s:125:"最大公共上升子序列(lcs)
    python实现: mit 算法导论公开课 15集 http://v.163.com/movie/... http://t.cn/zTHmomh";}}'
  _social_broadcast_meta: a:1:{s:7:"twitter";a:1:{i:334092962;a:0:{}}}
  _social_aggregated_ids: a:2:{s:7:"twitter";a:0:{}s:8:"facebook";a:0:{}}
  _social_aggregation_log: a:44:{i:1367989341;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1367993471;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1367995726;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1367997786;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1367998350;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1367998706;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368000333;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368000622;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368004636;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368005045;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368006252;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368007700;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368017654;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368017754;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368027324;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368044355;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368045812;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368046397;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368046639;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368076049;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368076440;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368077783;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368078305;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368078484;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368121811;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368122772;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368123158;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368126636;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368128276;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368131269;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368133367;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368137959;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368138757;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368139120;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368140931;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368143370;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368143445;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368230116;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368230408;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368230410;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368403313;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368406922;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368407731;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1368408451;O:8:"stdClass":1:{s:6:"manual";s:0:"";}}
author:
  login: snorlax
  email: zhangxzheng@hotmail.com
  display_name: snorlax
  first_name: ''
  last_name: ''
---
<p>mit 算法导论公开课 15集<br />
http://v.163.com/movie/2010/12/L/4/M6UTT5U0I_M6V2U1HL4.html</p>
<p>实现了求出所有的lcs</p>
<pre lang="python">
import copy
import sys
#stringa="abcbdab"
#stringb="bdcaba"

stringa=sys.argv[1]
stringb=sys.argv[2]
lena=len(stringa)
lenb=len(stringb)

mapl=[[0 for _ in xrange(lena+1)] for _ in xrange(lenb+1)]
path=[]
for i in xrange(1,lenb+1):
	for j in xrange(1,lena+1):
		if stringa[j-1]==stringb[i-1]:
			mapl[i][j]=mapl[i-1][j-1]+1
			path.append((i,j))
		else:
			mapl[i][j]=max(mapl[i-1][j],mapl[i][j-1])
#for i in mapl:
#	print i
#print path
if len(path)==0:
	print "no lcs"
else:
	backdatestack=[[(lenb,lena),[]]]
	while len(backdatestack)!=0:
		top=backdatestack.pop()
		ansstack=top[1]
		lcs=mapl[top[0][0]][top[0][1]]
		i=top[0][0]
		j=top[0][1]
		while lcs!=0:
			try:
				ind=path.index((i,j))
				ansstack.append(stringb[i-1])
				i-=1
				j-=1
				lcs-=1
			except ValueError:
				if mapl[i-1][j]>mapl[i][j-1]:
					i-=1
				elif mapl[i-1][j]<mapl[i][j-1]:
					j-=1
				else:
					backdatestack.append([(i-1,j),copy.copy(ansstack)])
					j-=1
		while len(ansstack)!=0:
			print ansstack.pop(),
		print 

</pre>
