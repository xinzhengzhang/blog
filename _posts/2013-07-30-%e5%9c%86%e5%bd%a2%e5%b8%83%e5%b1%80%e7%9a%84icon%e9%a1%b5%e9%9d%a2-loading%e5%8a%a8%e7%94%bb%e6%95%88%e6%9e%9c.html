---
layout: post
title: 圆形布局的icon页面 loading动画效果
categories:
- program
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _social_broadcast_content: 'a:1:{s:7:"twitter";a:1:{i:334092962;s:129:"圆形布局的icon页面
    loading动画效果:  大致效果就是3个元素根据不同时间间隔��... http://t.cn/zQiN4HT";}}'
  _sinaweibo_sync: 'true'
  _sinaweibo_sync_id: '3605780391837619'
  _social_notify: '1'
  _social_broadcast_meta: a:1:{s:7:"twitter";a:1:{i:334092962;a:0:{}}}
  _social_aggregation_log: a:10:{i:1375169904;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375173447;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375177157;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375181076;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375188873;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375205362;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375234360;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375280588;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375367358;O:8:"stdClass":1:{s:6:"manual";s:0:"";}i:1375541479;O:8:"stdClass":1:{s:6:"manual";s:0:"";}}
  _social_aggregated_ids: a:2:{s:7:"twitter";a:0:{}s:8:"facebook";a:0:{}}
  _social_broadcasted_ids: a:1:{s:7:"twitter";a:1:{i:334092962;a:1:{i:362109100630355968;a:3:{s:7:"message";s:3200:"eyJwbGFjZSI6bnVsbCwidHJ1bmNhdGVkIjpmYWxzZSwidXNlciI6eyJwcm9maWxlX2JhY2tncm91bmRfaW1hZ2VfdXJsIjoiaHR0cDpcL1wvYTAudHdpbWcuY29tXC9pbWFnZXNcL3RoZW1lc1wvdGhlbWUxXC9iZy5wbmciLCJuYW1lIjoic25vcmxheHp4eiIsInByb2ZpbGVfbGlua19jb2xvciI6IjAwODRCNCIsInZlcmlmaWVkIjpmYWxzZSwicHJvZmlsZV9pbWFnZV91cmwiOiJodHRwOlwvXC9hMC50d2ltZy5jb21cL3Byb2ZpbGVfaW1hZ2VzXC8zMzUyMzkwNjU5XC85NzNiZTE5NDg5ZGZjMzM5N2NiZTllMjU2MmEwMWNlM19ub3JtYWwuanBlZyIsImNyZWF0ZWRfYXQiOiJUdWUgSnVsIDEyIDE1OjI4OjQwICswMDAwIDIwMTEiLCJwcm9maWxlX2JhY2tncm91bmRfaW1hZ2VfdXJsX2h0dHBzIjoiaHR0cHM6XC9cL3NpMC50d2ltZy5jb21cL2ltYWdlc1wvdGhlbWVzXC90aGVtZTFcL2JnLnBuZyIsImlkX3N0ciI6IjMzNDA5Mjk2MiIsImRlZmF1bHRfcHJvZmlsZV9pbWFnZSI6ZmFsc2UsImZhdm91cml0ZXNfY291bnQiOjAsImlkIjoiMzM0MDkyOTYyIiwicHJvZmlsZV91c2VfYmFja2dyb3VuZF9pbWFnZSI6dHJ1ZSwiZW50aXRpZXMiOnsidXJsIjp7InVybHMiOlt7ImRpc3BsYXlfdXJsIjoic25vcmxheC5zaW5hYXBwLmNvbSIsImV4cGFuZGVkX3VybCI6Imh0dHA6XC9cL3Nub3JsYXguc2luYWFwcC5jb20iLCJpbmRpY2VzIjpbMCwyMl0sInVybCI6Imh0dHA6XC9cL3QuY29cL0hsTlg5SmdUZk4ifV19LCJkZXNjcmlwdGlvbiI6eyJ1cmxzIjpbXX19LCJwcm9maWxlX3RleHRfY29sb3IiOiIzMzMzMzMiLCJmcmllbmRzX2NvdW50IjoxMTYsImNvbnRyaWJ1dG9yc19lbmFibGVkIjpmYWxzZSwic2NyZWVuX25hbWUiOiJaaGFuZ1hpblpoZW5nIiwicHJvZmlsZV9zaWRlYmFyX2JvcmRlcl9jb2xvciI6IkMwREVFRCIsImZvbGxvd2Vyc19jb3VudCI6MTAsImxhbmciOiJ6aC1jbiIsInVybCI6Imh0dHA6XC9cL3QuY29cL0hsTlg5SmdUZk4iLCJ1dGNfb2Zmc2V0IjoyODgwMCwibm90aWZpY2F0aW9ucyI6ZmFsc2UsImlzX3RyYW5zbGF0b3IiOmZhbHNlLCJkZWZhdWx0X3Byb2ZpbGUiOnRydWUsImxvY2F0aW9uIjpudWxsLCJwcm9maWxlX2JhY2tncm91bmRfdGlsZSI6ZmFsc2UsInByb2ZpbGVfaW1hZ2VfdXJsX2h0dHBzIjoiaHR0cHM6XC9cL3NpMC50d2ltZy5jb21cL3Byb2ZpbGVfaW1hZ2VzXC8zMzUyMzkwNjU5XC85NzNiZTE5NDg5ZGZjMzM5N2NiZTllMjU2MmEwMWNlM19ub3JtYWwuanBlZyIsInRpbWVfem9uZSI6IkJlaWppbmciLCJmb2xsb3dfcmVxdWVzdF9zZW50IjpmYWxzZSwicHJvdGVjdGVkIjpmYWxzZSwicHJvZmlsZV9zaWRlYmFyX2ZpbGxfY29sb3IiOiJEREVFRjYiLCJkZXNjcmlwdGlvbiI6ImFjZ1xccHl0aG9uXFxpb3MiLCJsaXN0ZWRfY291bnQiOjIsInByb2ZpbGVfYmFja2dyb3VuZF9jb2xvciI6IkMwREVFRCIsImZvbGxvd2luZyI6ZmFsc2UsInN0YXR1c2VzX2NvdW50Ijo2OCwiZ2VvX2VuYWJsZWQiOnRydWV9LCJyZXR3ZWV0ZWQiOmZhbHNlLCJwb3NzaWJseV9zZW5zaXRpdmUiOmZhbHNlLCJpbl9yZXBseV90b19zdGF0dXNfaWQiOm51bGwsInNvdXJjZSI6IjxhIGhyZWY9XCJodHRwczpcL1wvc29wcmVzdG8ubWFpbGNoaW1wLmNvbVwiIHJlbD1cIm5vZm9sbG93XCI+U29jaWFsIFByb3h5IGJ5IE1haWxjaGltcDxcL2E+IiwiaWRfc3RyIjoiMzYyMTA5MTAwNjMwMzU1OTY4IiwiZ2VvIjpudWxsLCJpbl9yZXBseV90b19zY3JlZW5fbmFtZSI6bnVsbCwiaWQiOiIzNjIxMDkxMDA2MzAzNTU5NjgiLCJmYXZvcml0ZWQiOmZhbHNlLCJjcmVhdGVkX2F0IjoiVHVlIEp1bCAzMCAwNzoxNToxMSArMDAwMCAyMDEzIiwiaW5fcmVwbHlfdG9fc3RhdHVzX2lkX3N0ciI6bnVsbCwiY29vcmRpbmF0ZXMiOm51bGwsInRleHQiOiJcdTU3MDZcdTVmNjJcdTVlMDNcdTVjNDBcdTc2ODRpY29uXHU5ODc1XHU5NzYyIGxvYWRpbmdcdTUyYThcdTc1M2JcdTY1NDhcdTY3OWM6ICBcdTU5MjdcdTgxZjRcdTY1NDhcdTY3OWNcdTVjMzFcdTY2MmYzXHU0ZTJhXHU1MTQzXHU3ZDIwXHU2ODM5XHU2MzZlXHU0ZTBkXHU1NDBjXHU2NWY2XHU5NWY0XHU5NWY0XHU5Njk0XHVmZmZkXHVmZmZkLi4uIGh0dHA6XC9cL3QuY29cL3AyMGxrOHQyZW4iLCJpbl9yZXBseV90b191c2VyX2lkX3N0ciI6bnVsbCwiY29udHJpYnV0b3JzIjpudWxsLCJpbl9yZXBseV90b191c2VyX2lkIjpudWxsLCJlbnRpdGllcyI6eyJ1c2VyX21lbnRpb25zIjpbXSwiaGFzaHRhZ3MiOltdLCJ1cmxzIjpbeyJkaXNwbGF5X3VybCI6InQuY25cL3pRaU40SFQiLCJleHBhbmRlZF91cmwiOiJodHRwOlwvXC90LmNuXC96UWlONEhUIiwiaW5kaWNlcyI6WzUwLDcyXSwidXJsIjoiaHR0cDpcL1wvdC5jb1wvcDIwbGs4dDJlbiJ9XX0sInJldHdlZXRfY291bnQiOjB9";s:4:"urls";a:2:{i:0;s:33:"http://snorlax.sinaapp.com/?p=396";i:1;s:0:"";}s:7:"account";O:8:"stdClass":1:{s:4:"user";O:8:"stdClass":38:{s:2:"id";s:9:"334092962";s:6:"id_str";s:9:"334092962";s:4:"name";s:10:"snorlaxzxz";s:11:"screen_name";s:13:"ZhangXinZheng";s:8:"location";s:0:"";s:3:"url";s:26:"http://snorlax.sinaapp.com";s:11:"description";s:12:"acgpythonios";s:9:"protected";s:1:"0";s:15:"followers_count";s:2:"10";s:13:"friends_count";s:3:"100";s:12:"listed_count";s:1:"1";s:10:"created_at";s:30:"Tue
    Jul 12 15:28:40 +0000 2011";s:16:"favourites_count";s:1:"0";s:10:"utc_offset";s:5:"28800";s:9:"time_zone";s:7:"Beijing";s:11:"geo_enabled";s:1:"1";s:8:"verified";s:1:"0";s:14:"statuses_count";s:2:"14";s:4:"lang";s:5:"zh-cn";s:6:"status";a:11:{s:10:"created_at";s:30:"Fri
    Mar 08 07:59:58 +0000 2013";s:2:"id";s:18:"309936517424484352";s:6:"id_str";s:18:"309936517424484352";s:4:"text";s:88:"关于编写高性能服务器的资料汇总(Linux)
    | Ace's Blog http://t.co/CIFIvJkrru";s:6:"source";s:12:"Tweet Button";s:9:"truncated";s:1:"0";s:13:"retweet_count";s:1:"0";s:9:"favorited";s:1:"0";s:9:"retweeted";s:1:"0";s:18:"possibly_sensitive";s:1:"0";s:4:"lang";s:2:"zh";}s:20:"contributors_enabled";s:1:"0";s:13:"is_translator";s:1:"0";s:24:"profile_background_color";s:6:"C0DEED";s:28:"profile_background_image_url";s:47:"http://a0.twimg.com/images/themes/theme1/bg.png";s:34:"profile_background_image_url_https";s:49:"https://si0.twimg.com/images/themes/theme1/bg.png";s:23:"profile_background_tile";s:1:"0";s:17:"profile_image_url";s:90:"http://a0.twimg.com/profile_images/3352390659/973be19489dfc3397cbe9e2562a01ce3_normal.jpeg";s:23:"profile_image_url_https";s:92:"https://si0.twimg.com/profile_images/3352390659/973be19489dfc3397cbe9e2562a01ce3_normal.jpeg";s:18:"profile_link_color";s:6:"0084B4";s:28:"profile_sidebar_border_color";s:6:"C0DEED";s:26:"profile_sidebar_fill_color";s:6:"DDEEF6";s:18:"profile_text_color";s:6:"333333";s:28:"profile_use_background_image";s:1:"1";s:15:"default_profile";s:1:"1";s:21:"default_profile_image";s:1:"0";s:9:"following";s:1:"0";s:19:"follow_request_sent";s:1:"0";s:13:"notifications";s:1:"0";}}}}}}
author:
  login: snorlax
  email: zhangxzheng@hotmail.com
  display_name: snorlax
  first_name: ''
  last_name: ''
---
<p><a href="http://snorlax-wordpress.stor.sinaapp.com/uploads/2013/07/700BAD52-7C3F-4500-8B52-69C13291528D.jpg"><img src="http://snorlax-wordpress.stor.sinaapp.com/uploads/2013/07/700BAD52-7C3F-4500-8B52-69C13291528D.jpg" alt="" title="700BAD52-7C3F-4500-8B52-69C13291528D" width="314" height="470" class="alignnone size-full wp-image-397" /></a><br />
大致效果就是3个元素根据不同时间间隔开始沿着圆进行无限追逐，每次一圈后进行一个小停顿然后继续、比较类似wp7的那种小的loading、主要用到的还是CAKeyframeAnimation其中为了让无限循环中加上停顿用了个小trick</p>
<pre lang="c">
#import <QuartzCore/QuartzCore.h>
#define PI 3.14159265358979323846

@interface canvas ()
{
    UIButton *red;
    UIButton *green;
    UIButton *yellow;
}

@end

@implementation canvas

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        // Initialization code
        red=[[UIButton alloc]initWithFrame:CGRectMake(117.55-10, 38.1-10, 10, 10)];
        green=[[UIButton alloc]initWithFrame:CGRectMake(141.42-10, 58.57-10, 10, 10)];
        yellow=[[UIButton alloc]initWithFrame:CGRectMake(173.2-10, 100-10, 10, 10)];
        
        [red setBackgroundColor:[UIColor redColor]];
        [green setBackgroundColor:[UIColor greenColor]];
        [yellow setBackgroundColor:[UIColor yellowColor]];
        
        [red addTarget:self action:@selector(end) forControlEvents:UIControlEventTouchUpInside];
        [yellow addTarget:self action:@selector(start) forControlEvents:UIControlEventTouchUpInside];

        
        [self start];
        [self addSubview:red];
        [self addSubview:green];
        [self addSubview:yellow];
    }
    return self;
}
-(void)end{
    [red.layer removeAllAnimations];
    [green.layer removeAllAnimations];
    [yellow.layer removeAllAnimations];

    
}
-(void)start{
   
    CGMutablePathRef path=CGPathCreateMutable();
    CGPathAddArc(path, NULL, 0.0f, 200.0f, 200, -0.8424, -0.8424+2*PI, NO);//用cgpath画出运动轨迹
    CGPathAddArc(path, NULL, 0.0f, 200.0f, 200, -0.8424, -0.9424, YES);
    
    
    
        
    CAKeyframeAnimation *animation=[CAKeyframeAnimation animationWithKeyPath:@"position"];
    [animation setCalculationMode:kCAAnimationPaced];
    [animation setPath:path];
    [animation setDuration:2.0f];
    [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];
//    [animation setBeginTime:CACurrentMediaTime()+0.7];
//    [animation setRepeatCount:HUGE_VALF];
    CFRelease(path);
    
    
    
    
    CAAnimationGroup *animationGroup = [CAAnimationGroup animation];//利用动画组的间隔做到小动画的无限间隔之间的停顿
    animationGroup.duration = 3;
    animationGroup.repeatCount = INFINITY;
    animationGroup.animations=@[animation];
    [animationGroup setBeginTime:CACurrentMediaTime()+0.5];//让三个元素起始时间区分开
    [red.layer addAnimation:animationGroup forKey:NULL];
    
    path=CGPathCreateMutable();
    CGPathAddArc(path, NULL, 0.0f, 200.0f, 200, -0.683, -0.683+2*PI, NO);
    CGPathAddArc(path, NULL, 0.0f, 200.0f, 200, -0.683, -0.783, YES);
    animation=[CAKeyframeAnimation animationWithKeyPath:@"position"];
    [animation setCalculationMode:kCAAnimationPaced];
    [animation setPath:path];
    [animation setDuration:2.0f];
    [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];
//    [animation setBeginTime:CACurrentMediaTime()+0.5];
//    [animation setRepeatCount:HUGE_VALF];

    CFRelease(path);
    
    
    animationGroup = [CAAnimationGroup animation];
    animationGroup.duration = 3;
    animationGroup.repeatCount = INFINITY;
    animationGroup.animations=@[animation];
    [animationGroup setBeginTime:CACurrentMediaTime()+0.2];
    [green.layer addAnimation:animationGroup forKey:NULL];
    
    path=CGPathCreateMutable();
    CGPathAddArc(path, NULL, 0.0f, 200.0f, 200, -0.425, -0.425+2*PI, NO);
    CGPathAddArc(path, NULL, 0.0f, 200.0f, 200, -0.425, -0.525, YES);
    animation=[CAKeyframeAnimation animationWithKeyPath:@"position"];
    [animation setCalculationMode:kCAAnimationPaced];
    [animation setPath:path];
    [animation setDuration:2.0f];
//    [animation setRepeatCount:HUGE_VALF];

    [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];

    CFRelease(path);
        
    animationGroup = [CAAnimationGroup animation];
    animationGroup.duration = 3;
    animationGroup.repeatCount = INFINITY;
    animationGroup.animations=@[animation];
    
    [yellow.layer addAnimation:animationGroup forKey:NULL];
    

    
    
}

// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect
{
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetStrokeColor(context, [UIColor blueColor].CGColor);
    CGContextAddArc(context, 0.0, 200.0f, 200, 0, 2*PI, YES);

    [[UIColor orangeColor] setFill];
    [[UIColor blueColor] setStroke];
    CGContextDrawPath (context, kCGPathStroke);

}


@end

</pre>
