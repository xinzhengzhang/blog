---
layout: post
title: 关于gcc优化拷贝构造
categories:
- program
tags: []
published: true
comments: true
---
<p>今天碰到一个很奇怪的问题……(我大一的时候怎么没有发觉呢Orz<br />
代码如下
<pre lang="c">
#include <iostream>
using namespace std;
class Student {
    
public:
    Student(){cout<<"structure"<<endl;}
    Student(const Student &temp)
    {</iostream></pre></p>

<p>        cout<<"copy structure"<<endl;<br />
    }<br />
    ~Student(){</p>

<p>        cout<<"free"<<endl;}<br />
    Student  operator + (const Student &) const<br />
    {<br />
        Student temp;<br />
        return temp; <br />
    }<br />
};<br />
int main(int argc, const char * argv[])<br />
{</p>

<p>    Student s1;<br />
    Student s2(s1+s1);<br />
    return 0;<br />
}

输出应该很简单<br />
------------------<br />
structure<br />
structure<br />
copy structure<br />
free<br />
copy structure<br />
free<br />
free<br />
free<br />
-----------------<br />
return 返回临时变量时应该拷贝构造一次<br />
可是问题来了 死活出的结果就是<br />
----------------<br />
structure<br />
structure<br />
free<br />
free<br />
----------------<br />
折腾了大半天后我终于还是发现原来还是编译器搞的鬼……(人家只是太智能不要黑他<br />
具体就是在return temp;那里应该隐式调用拷贝构造的地方编译器做了延长temp的生命周期、延长到外部s2来让s2的生命周期结束后对这块内存进行析构<br />
这样就可以少了第一次拷贝构造<br />
此时第二次需要把新对象拷贝到s2中时的拷贝也就在这里被一起优化掉了直接让s2对应到了temp这块内存上(以上是我对编译器优化过程的的猜测<br />
然后我就试着<br />
g++ -o test -O0 test.cpp<br />
这么编译还是不行<br />
于是我就放弃了(只好理解成gcc的最白痴的不进行优化编译也会处理掉这种隐式的拷贝构造<br />
但是我错了！！！<br />
我严重鄙视下大多数网上放gcc参数的文档的那些人不负责任的就是-O0就是不优化（混蛋不优化不等于最低级优化好么！<br />
-----------------<br />
然后终于在帮忙下找到了http://blog.csdn.net/daidodo/article/details/2185217这篇文章<br />
-fno-elide-constructors 强制g++总是调用copy构造函数，即使在用临时对象初始化另一个同类型对象的时候。<br />
就是这个参数<br />
好了一切其实也就搞定了<br />
g++ -o test -fno-elide-constructors test.cpp</p>

<p>结束语:怪也只能怪gcc太尼玛智能了……我大概知道为什么开始教学中要用vc环境了</p>
