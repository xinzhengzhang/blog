---
layout: post
title: list中判断是否存在三角形三边
categories:
- program
tags: []
published: true
comments: true
---
<p>小时候数学好、因为能够有感觉知道每个条件他存在的意义、到了大学这种感觉渐渐消失了、直到今天突然那种感觉就回来了、因为那些条件恰恰是隐藏在数学自己的本身……<br />
--------------------------------------------------------------------------<br />
把这个感觉带回给我的恰恰就是这么一道题、这道题真的非常非常简单、可是给我带来了不小的顿悟。原题大致是先图里求个最短路径然后判断路径中是否有可以组成三角形的存在<br />
也就是拆出了这么一个子问题、不知道是计算机编程写多了还是怎么样、已经逐渐开始依赖计算机强大的计算脑子都没半动一下就开始O(n^3)的暴力
<pre lang="c++">
for(int a=0; a < pcnt && !flag; a++)
{
    for(int b=a+1; b < pcnt && !flag; b++)
    {
        for(int c=b+1; c < pcnt && !flag; c++)
        {
            if(judge(pval[a],pval[b],pval[c]))
            {
                flag=true;
            }
        }
    }
}
</pre>
拿脚趾头想三次方肯定要TL、接着就是开始改进、首先想到了还是先对这些有意义的数组进行排序。然后使用自然而然的递增数组自己的优势那就是最小的两边之差一定是存在与相邻的数字里、注意这里就利用到了数字这个自身拥有美丽的属性的东西的属性。然后差不多代码是这样的
<pre lang="c++">
for (int a = 0; a < pcnt-2 && !flag; ++a)
{
    for(int j=a+1;j < pcnt-1 && !flag;j++)
    {
                    
        if (pval[a] > (pval[j+1]-pval[j]))
        {
            flag=true;
        }
    }
}
</pre>
复杂度是O(n^2)当我们使用了数字他自身的属性后、也就是相当于他自身的一个条件、我们把一个复杂度进行了指数级别的下降、这是多么美妙的事情？当然还没有完、因为我们还有一个隐藏条件<br />
首先想想我们如何判定一个三角形<br />
1.所有任意两边之和大于第三边<br />
2.存在任意两边之差小于第三边<br />
条件1其实就等于是3个条件、为什么对判断同一个东西却判断的条件不同？原因就是存在于他们的符号、因为减法这个运算他本身就更为苛刻破坏了数字之间那种稳定的感觉（对不起我实在没有专业知识来说明这个感觉是什么）而看起来要判断三次的加法就非常好的维护了这个感觉、也就是我们小时候做数学的那种条件是正正好好的感觉、只是现在他们隐藏于了数字本身<br />
所以最终的代码其实非常简单</p>

<p><pre lang="c++" /></p>

<p>for(int i=0;i < pcnt-2;i++)<br />
{
    if(pval[i]+pval[i+1] > pv[i+2])<br />
        break;<br />
}

通过数字他自身我们其实只需要O(n)足已</p>
