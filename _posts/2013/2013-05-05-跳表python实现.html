---
layout: post
title: 跳表python实现
categories:
- program
tags: []
published: true
comments: true
---
<p>最近在看算法导论发现跳表好像一直没实现过……所以闲来无视就写了个python的实现<br />
详细介绍可看网易公开课算法导论第12集跳跃表<br />
http://v.163.com/special/opencourse/algorithms.html</p>

<p>然后把代码贴上
<pre lang="python">import sys
import random
mineast=-sys.maxint
class Node(object):
	def __init__(self,value=mineast,rightp=None,leftp=None,upp=None,downp=None):
		self.value=value
		self.rightp=rightp
		self.leftp=leftp
		self.upp=upp
		self.downp=downp
	def __del__(self):
		self.value=None
		self.rightp=None
		self.leftp=None
		self.upp=None
		self.downp=None
class skipTable(object):
	def __init__(self):
		self.lefthead=Node()
	def __del__(self):
		t=self.lefthead
		headlist=[]
		while t:
			headlist.append(t)
			t=t.downp
		for i in headlist:
			while i:
				dd=i
				i=i.rightp
				del(dd)</pre></p>

<p>	def findlowestLayer(self,newvalue):<br />
		tmphead=self.lefthead<br />
		tmpans=[]<br />
		while tmphead.downp:<br />
			while tmphead.rightp:<br />
				if tmphead.rightp.value&gt;newvalue:<br />
					break<br />
				else:<br />
					tmphead=tmphead.rightp<br />
			tmpans.append(tmphead)<br />
			tmphead=tmphead.downp<br />
		tmpans.append(tmphead)<br />
		return tmpans<br />
	def getCurrentLayerInsertLoc(self,Head,newvalue):<br />
		tmphead=Head<br />
		while(tmphead.rightp):<br />
			if tmphead.rightp.value&gt;newvalue:<br />
				return tmphead<br />
			else:<br />
				tmphead=tmphead.rightp<br />
		return tmphead<br />
	def randomup(self):<br />
		if random.randint(0,1)==0:<br />
			return False<br />
		else:<br />
			return True<br />
	def adjustnode(self,prefixNode,value):<br />
		newnode=Node(value,prefixNode.rightp,prefixNode,None,None)<br />
		if prefixNode.rightp:<br />
			prefixNode.rightp.leftp=newnode<br />
			prefixNode.rightp=newnode<br />
		else:<br />
			prefixNode.rightp=newnode<br />
		return newnode<br />
	def adjustnodepor(self,prefixNode,downNode,value):<br />
		newnode=Node(value,prefixNode.rightp,prefixNode,None,downNode)<br />
		downNode.upp=newnode<br />
		if prefixNode.rightp:<br />
			prefixNode.rightp.leftp=newnode<br />
			prefixNode.rightp=newnode<br />
		else:<br />
			prefixNode.rightp=newnode<br />
		return newnode<br />
	def insert(self,value):<br />
		lowestlayerNode=self.findlowestLayer(value)<br />
		loc=self.getCurrentLayerInsertLoc(lowestlayerNode.pop(),value)<br />
		downNode=self.adjustnode(loc,value)<br />
		while self.randomup():<br />
			#print "up %s" %value<br />
			if(len(lowestlayerNode)!=0):<br />
				downNode=self.adjustnodepor(lowestlayerNode.pop(),downNode,value)<br />
			else:<br />
				newnode=Node()<br />
				newnode.downp=self.lefthead<br />
				self.lefthead.upp=newnode<br />
				self.lefthead=newnode<br />
				downNode=self.adjustnodepor(newnode,downNode,value)<br />
	def delete(self,value):<br />
		lowestlayerNode=self.findlowestLayer(value)<br />
		loc=self.getCurrentLayerInsertLoc(lowestlayerNode.pop(),value)<br />
		lowestlayerNode.append(loc)<br />
		for i in lowestlayerNode:<br />
			if i.value==value:<br />
				if i.rightp:<br />
					i.leftp.rightp=i.rightp<br />
					i.rightp.leftp=i.leftp<br />
					del(i)<br />
				else:<br />
					i.leftp.rightp=None<br />
					del(i)<br />
	def find(self,value):<br />
		tmphead=self.lefthead<br />
		while tmphead.downp:<br />
			while tmphead.rightp:<br />
				if tmphead.rightp.value&gt;value:<br />
					break<br />
				elif tmphead.rightp.value==value:<br />
					print "find"<br />
					return<br />
				else:<br />
					tmphead=tmphead.rightp<br />
			tmphead=tmphead.downp<br />
		while tmphead.rightp:<br />
			if tmphead.rightp.value==value:<br />
				print "find"<br />
				return<br />
			tmphead=tmphead.rightp<br />
		if tmphead.value==value:<br />
			print "find"<br />
			return<br />
		else:<br />
			print "not find"<br />
			return</p>

<p>sk=skipTable()<br />
for i in xrange(100):<br />
	sk.insert(random.randint(0,100))<br />
for i in xrange(20):<br />
	sk.delete(random.randint(0,100))</p>

<p>t=sk.lefthead<br />
headlist=[]<br />
while t:<br />
	headlist.append(t)<br />
	t=t.downp<br />
for i in headlist:<br />
	while i:<br />
		print i.value,<br />
		i=i.rightp<br />
	print <br />
sk.find(101)<br />
del(sk)</p>
