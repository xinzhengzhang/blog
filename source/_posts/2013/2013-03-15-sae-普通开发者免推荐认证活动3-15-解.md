---
date: 2013-03-15
layout: post
title: sae 普通开发者免推荐认证活动3.15 解
categories:
- program
tags: []
published: true
comments: true
---
<p><a href="http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=12876">大家好我是传送门</a></p>

<p>活动如上<br />
主要题干是<br />
请将昨天的100位数字，使用你熟悉的编程语言，首先将其由字符串转换为长度为100的整数数组；其次，对数组进行排序，实现奇数在左边，偶数在右边，并且分别有序，希望最多只使用O(1)的空间复杂度（如能不借助额外空间实现排序，首位完成者将有惊喜~）。</p>

<p>数字如下：31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823</p>

<p>其实难度也不大、主要就是想出了一个非常巧妙的方法解决<br />
首先没有时间复杂度要求 但对空间要求零空间 脑子第一反应就是快排 但是最大的问题就是如何再零空间下把奇偶分开然后分别快排即可<br />
就是两个游标的交互替换、写出来就是感觉非常巧妙啦:)</p>

<p>代码如下</p>

<p>
```

i=-1
j=0
pi = "31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823"
l = [int(tt) for tt in pi[:100]]
while j

print sorted(l[0:i+1])+sorted(l[i+1:100])

经过评论大哥的指点python的实现

pi = "31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823"
l=[int(tt) for tt in pi[:100]]
l.sort(lambda x,y:(x-y)if(x%2-y%2==0)else(y%2-x%2))
print l

>

```
